name: Sign and Package macOS App
on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  sign-and-package:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download unsigned app
      uses: dawidd6/action-download-artifact@v2
      with:
        workflow: macos-app-build.yml
        name: AV-Spex-App
        path: dist/app_download/
        
    - name: Download version info
      uses: dawidd6/action-download-artifact@v2
      with:
        workflow: macos-app-build.yml
        name: app-version
        path: dist/
        
    - name: Set version
      run: |
        if [ -f "dist/version.txt" ]; then
          VERSION=$(cat dist/version.txt)
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          echo "Found version file with version: $VERSION"
        else
          # Fallback: extract version from pyproject.toml
          echo "Version file not found. Extracting from pyproject.toml..."
          VERSION=$(grep -m 1 "version" pyproject.toml | grep -o '"[^"]*"' | sed 's/"//g')
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          echo "Extracted version from pyproject.toml: $VERSION"
        fi
        
    - name: Verify downloaded artifacts
      run: |
        echo "Checking downloaded artifacts..."
        ls -la dist/
        ls -la dist/app_download/
        echo "Using version: $APP_VERSION"
        
    - name: Prepare app bundle
      run: |
        echo "Preparing app bundle..."
        
        # See if Contents folder is at the root or inside an .app bundle
        if [ -d "dist/app_download/Contents" ]; then
          echo "Found Contents folder at root of artifact"
          mkdir -p "dist/AV-Spex.app"
          cp -R dist/app_download/Contents "dist/AV-Spex.app/"
        elif [ -d "dist/app_download/AV-Spex.app" ]; then
          echo "Found AV-Spex.app directory inside artifact"
          cp -R dist/app_download/AV-Spex.app dist/
        else
          echo "Couldn't find expected app structure, will try to use what we have"
          echo "Contents of app_download:"
          find dist/app_download -type d | head -10
          mkdir -p "dist/AV-Spex.app/Contents"
          cp -R dist/app_download/* "dist/AV-Spex.app/Contents/"
        fi
        
        # Verify the app bundle structure
        echo "Verifying app bundle structure..."
        ls -la dist/AV-Spex.app/Contents/
        ls -la dist/AV-Spex.app/Contents/MacOS/
        
        # Create DMG preparation folder and copy app
        echo "Creating DMG preparation folder..."
        mkdir -p dist/dmg
        cp -R "dist/AV-Spex.app" dist/dmg
        chmod -R 755 dist/dmg/AV-Spex.app
        
    - name: Set up keychain
      env:
        CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create temporary keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        
        # Import certificate to keychain
        echo "$CERTIFICATE_BASE64" | base64 --decode > certificate.p12
        security import certificate.p12 -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH
        
        # Verify certificate was imported
        security find-identity -v $KEYCHAIN_PATH
        
        # Delete the certificate file
        rm certificate.p12
        
    - name: Setup notarytool credentials
      run: |
        xcrun notarytool store-credentials "GITHUB_ACTIONS_PROFILE" \
          --apple-id ${{ secrets.APPLE_ID }} \
          --team-id ${{ secrets.APPLE_TEAM_ID }} \
          --password ${{ secrets.APPLE_ID_PASSWORD }}
          
    - name: Create entitlements file
      run: |
        cat > entitlements.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.cs.allow-jit</key>
            <true/>
            <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
            <true/>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
            <key>com.apple.security.cs.allow-dyld-environment-variables</key>
            <true/>
            <key>com.apple.security.automation.apple-events</key>
            <true/>
        </dict>
        </plist>
        EOF
        
    - name: Sign app bundle with proper order
      env:
        DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
      run: |
        echo "Starting comprehensive code signing process..."
        echo "Using Developer ID: $DEVELOPER_ID"
        
        # Function to sign a binary file
        sign_binary() {
          local file="$1"
          local use_entitlements="$2"
          
          if [ ! -f "$file" ]; then
            return 0
          fi
          
          # Skip symlinks - we only want to sign actual binaries
          if [ -L "$file" ]; then
            return 0
          fi
          
          # Check if it's a binary file
          if ! file "$file" | grep -q "Mach-O\|executable\|shared library"; then
            return 0
          fi
          
          echo "Signing: $file"
          if [ "$use_entitlements" = "true" ]; then
            if codesign --force --timestamp --options runtime --entitlements entitlements.plist --sign "$DEVELOPER_ID" "$file"; then
              echo "✓ Successfully signed: $file"
            else
              echo "❌ Failed to sign: $file"
            fi
          else
            if codesign --force --timestamp --options runtime --sign "$DEVELOPER_ID" "$file"; then
              echo "✓ Successfully signed: $file"
            else
              echo "❌ Failed to sign: $file"
            fi
          fi
        }
        
        # Clean up problematic files and fix Python framework structure
        echo "Cleaning up problematic files..."
        find dist/dmg/AV-Spex.app/Contents -name "pyproject.toml" -delete 2>/dev/null || true
        
        # Fix malformed Python framework - remove the top-level Python binary that's causing issues
        for location in "dist/dmg/AV-Spex.app/Contents/Frameworks" "dist/dmg/AV-Spex.app/Contents/Resources"; do
          if [ -f "$location/Python.framework/Python" ] && [ ! -L "$location/Python.framework/Python" ]; then
            echo "Removing problematic Python framework binary: $location/Python.framework/Python"
            rm -f "$location/Python.framework/Python"
          fi
        done
        
        # Remove Qt framework main binaries that are causing "bundle format is ambiguous" errors
        QT_FRAMEWORKS="QtCore QtGui QtWidgets QtNetwork QtSvg QtDBus QtPdf"
        for framework in $QT_FRAMEWORKS; do
          for location in "dist/dmg/AV-Spex.app/Contents/Frameworks" "dist/dmg/AV-Spex.app/Contents/Resources"; do
            framework_binary="$location/PyQt6/Qt6/lib/${framework}.framework/${framework}"
            if [ -f "$framework_binary" ] && [ ! -L "$framework_binary" ]; then
              echo "Removing problematic Qt framework binary: $framework_binary"
              rm -f "$framework_binary"
            fi
          done
        done
        
        # Phase 1: Sign all .so files (Python extensions)
        echo "Phase 1: Signing Python extension modules..."
        find dist/dmg/AV-Spex.app/Contents -name "*.so" | while read file; do
          sign_binary "$file" false
        done
        
        # Phase 2: Sign all .dylib files (dynamic libraries)
        echo "Phase 2: Signing dynamic libraries..."
        find dist/dmg/AV-Spex.app/Contents -name "*.dylib" | while read file; do
          sign_binary "$file" false
        done
        
        # Phase 3: Sign Qt framework versioned binaries only
        echo "Phase 3: Signing Qt framework versioned binaries..."
        for framework in $QT_FRAMEWORKS; do
          for base_path in "dist/dmg/AV-Spex.app/Contents/Frameworks" "dist/dmg/AV-Spex.app/Contents/Resources"; do
            # Sign only the versioned framework binaries (Versions/A/QtXxx and Versions/Current/QtXxx)
            find "$base_path" -path "*/${framework}.framework/Versions/*/${framework}" -type f 2>/dev/null | while read file; do
              sign_binary "$file" false
            done
            
            # Also sign direct Qt binaries in Resources (flat structure)
            if [ -f "$base_path/${framework}" ]; then
              sign_binary "$base_path/${framework}" false
            fi
          done
        done
        
        # Phase 4: Sign Python framework versioned binaries only
        echo "Phase 4: Signing Python framework versioned binaries..."
        for base_path in "dist/dmg/AV-Spex.app/Contents/Frameworks" "dist/dmg/AV-Spex.app/Contents/Resources"; do
          # Sign versioned Python binaries
          find "$base_path" -path "*/Python.framework/Versions/*/Python" -type f 2>/dev/null | while read file; do
            sign_binary "$file" false
          done
          
          # Also sign direct Python binary in Resources (flat structure)
          if [ -f "$base_path/Python" ]; then
            sign_binary "$base_path/Python" false
          fi
        done
        
        # Phase 5: Sign main executable with entitlements
        echo "Phase 5: Signing main executables..."
        find dist/dmg/AV-Spex.app/Contents/MacOS -type f -perm +111 2>/dev/null | while read file; do
          sign_binary "$file" true
        done
        
        # Phase 6: Try to sign the main app bundle without --deep first
        echo "Phase 6: Signing main application bundle..."
        if codesign --force --timestamp --options runtime --entitlements entitlements.plist --sign "$DEVELOPER_ID" dist/dmg/AV-Spex.app; then
          echo "✓ Standard signing successful"
        else
          echo "Standard signing failed, trying with --deep flag..."
          if codesign --force --deep --timestamp --options runtime --entitlements entitlements.plist --sign "$DEVELOPER_ID" dist/dmg/AV-Spex.app; then
            echo "✓ Deep signing successful"
          else
            echo "❌ Both signing attempts failed"
            exit 1
          fi
        fi
        
        # Verify the signature
        echo "Verifying code signature..."
        if codesign --verify --deep --verbose dist/dmg/AV-Spex.app; then
          echo "✓ Code signature verification successful"
        else
          echo "⚠ Code signature verification failed"
          # Try to get more details about what failed
          codesign --verify --verbose=4 dist/dmg/AV-Spex.app 2>&1 || true
          echo "Continuing despite verification failure..."
        fi
        
        # Create DMG
        echo "Creating DMG with hdiutil..."
        if hdiutil create -volname "AV-Spex $APP_VERSION" -srcfolder dist/dmg -ov -format UDZO "dist/AV-Spex-$APP_VERSION.dmg"; then
          echo "✓ DMG creation successful"
        else
          echo "❌ DMG creation failed"
          exit 1
        fi
          
        # Sign the DMG
        echo "Signing DMG..."
        if codesign --force --timestamp --sign "$DEVELOPER_ID" "dist/AV-Spex-$APP_VERSION.dmg"; then
          echo "✓ DMG signing successful"
        else
          echo "❌ DMG signing failed"
          exit 1
        fi
        
    - name: Notarize DMG with detailed logs
      run: |
        # Submit for notarization
        echo "Submitting DMG for notarization..."
        SUBMISSION_ID=$(xcrun notarytool submit "dist/AV-Spex-$APP_VERSION.dmg" \
          --keychain-profile "GITHUB_ACTIONS_PROFILE" \
          --wait --timeout 1800 | grep "id:" | head -1 | awk '{print $2}')
        
        echo "Submission ID: $SUBMISSION_ID"
        
        # Get detailed notarization log
        echo "Getting detailed notarization log..."
        xcrun notarytool log $SUBMISSION_ID --keychain-profile "GITHUB_ACTIONS_PROFILE"
        
        # Check status
        STATUS=$(xcrun notarytool info $SUBMISSION_ID --keychain-profile "GITHUB_ACTIONS_PROFILE" | grep "status:" | awk '{print $2}')
        
        if [ "$STATUS" = "Accepted" ]; then
          echo "Notarization successful, stapling ticket..."
          xcrun stapler staple "dist/AV-Spex-$APP_VERSION.dmg"
        else
          echo "Notarization failed with status: $STATUS"
          echo "Will continue to upload unsigned DMG as artifact"
        fi
        
    - name: Upload signed app as artifact
      uses: actions/upload-artifact@v4
      with:
        name: AV-Spex-Signed-App
        path: dist/dmg/AV-Spex.app/
        
    - name: Upload DMG as artifact (even if notarization failed)
      uses: actions/upload-artifact@v4
      with:
        name: AV-Spex-DMG
        path: dist/AV-Spex-${{ env.APP_VERSION }}.dmg
        
    - name: Attach to Release
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: |
          dist/AV-Spex-${{ env.APP_VERSION }}.dmg
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
