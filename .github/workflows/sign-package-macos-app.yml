name: Sign and Package macOS App

on:
  workflow_run:
    workflows: ["Build macOS App"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      build_run_id:
        description: 'Build workflow run ID to sign'
        required: true
        type: string
      version:
        description: 'Version to sign (optional, will be detected from build)'
        required: false
        type: string

permissions:
  contents: write  # Required to create releases
  actions: read    # Required to download artifacts
  id-token: write  # Add this for better token handling

jobs:
  sign-and-package:
    runs-on: macos-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Ensure we checkout the correct ref when triggered by workflow_run
        ref: ${{ github.event.workflow_run.head_sha || github.sha }}

    - name: Debug workflow_run context
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Triggering workflow run ID: ${{ github.event.workflow_run.id }}"
        echo "Triggering workflow name: ${{ github.event.workflow_run.name }}"
        echo "Triggering workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
        echo "Head branch: ${{ github.event.workflow_run.head_branch }}"
        echo "Head SHA: ${{ github.event.workflow_run.head_sha }}"
        echo "Event type: ${{ github.event.workflow_run.event }}"
        echo "Repository: ${{ github.event.workflow_run.repository.full_name }}"
        echo "All workflow_run context:"
        echo '${{ toJson(github.event.workflow_run) }}'
      
    - name: Install dependencies
      run: |
        # Install create-dmg (jq is pre-installed on GitHub runners)
        brew install create-dmg
        
    - name: Download unsigned app bundle
      uses: actions/download-artifact@v4
      with:
        pattern: av-spex-*-unsigned
        path: ./artifacts
        run-id: ${{ github.event.inputs.build_run_id || github.event.workflow_run.id }}
        github-token: ${{ secrets.GITHUB_TOKEN }}
        merge-multiple: true
        
    - name: Extract build artifacts and get version
      run: |
        ls -la artifacts/
        
        # Find the universal build (preferred) or fall back to any build
        UNIVERSAL_ARCHIVE=$(find artifacts -name "*universal-unsigned.tar.gz" | head -1)
        if [ -n "$UNIVERSAL_ARCHIVE" ]; then
          APP_ARCHIVE="$UNIVERSAL_ARCHIVE"
          echo "✅ Using universal build: $APP_ARCHIVE"
        else
          # Fall back to any available archive
          APP_ARCHIVE=$(find artifacts -name "*.tar.gz" | head -1)
          echo "⚠️  Universal build not found, using: $APP_ARCHIVE"
        fi
        
        if [ -z "$APP_ARCHIVE" ]; then
          echo "❌ No app bundle archive found!"
          exit 1
        fi
        
        echo "Extracting: $APP_ARCHIVE"
        mkdir -p dist
        tar -xzf "$APP_ARCHIVE" -C dist/
        
        # The build-info.json should now be in dist/ after extraction
        if [ -f "dist/build-info.json" ]; then
          echo "📄 Found build info file: dist/build-info.json"
          cat "dist/build-info.json"
          
          # Extract version from build info
          if command -v jq > /dev/null; then
            VERSION=$(cat "dist/build-info.json" | jq -r '.version')
          else
            # Fallback method without jq
            VERSION=$(cat "dist/build-info.json" | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
          fi
          
          if [ "$VERSION" = "null" ] || [ -z "$VERSION" ]; then
            echo "❌ Failed to extract version from build info"
            exit 1
          fi
          
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "✅ Found version: $VERSION"
        else
          echo "❌ Build info not found in extracted archive!"
          echo "Contents of dist/:"
          ls -la dist/
          exit 1
        fi
        
        # Verify app bundle exists
        if [ -d "dist/AV-Spex.app" ]; then
          echo "✅ App bundle extracted successfully"
          # Show what architecture(s) we have
          echo "Architecture info:"
          file "dist/AV-Spex.app/Contents/MacOS/AV-Spex"
          lipo -info "dist/AV-Spex.app/Contents/MacOS/AV-Spex" 2>/dev/null || echo "(Single architecture binary)"
        else
          echo "❌ App bundle not found after extraction!"
          echo "Contents of dist/:"
          ls -la dist/
          exit 1
        fi
        
    - name: Import Code Signing Certificate
      env:
        APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
        APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create variables
        CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

        # Import certificate from secrets
        echo -n "$APPLE_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH

        # Create temporary keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        # Import certificate to keychain
        security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH
        
        # Get the certificate name for signing
        CERT_NAME=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Developer ID Application" | head -1 | grep -o '"[^"]*"' | sed 's/"//g')
        echo "CERT_NAME=$CERT_NAME" >> $GITHUB_ENV
        echo "Found certificate: $CERT_NAME"
        
    - name: Verify Apple credentials before notarization
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "🔍 Verifying Apple credentials..."
        echo "Apple ID: ${APPLE_ID:0:3}***${APPLE_ID: -3}"
        echo "Team ID: ${APPLE_TEAM_ID:0:3}***${APPLE_TEAM_ID: -3}"
        
        # Test the credentials first
        echo "Testing notarization credentials..."
        xcrun notarytool store-credentials "TEMP_TEST_PROFILE" \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_ID_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" || {
            echo "❌ Notarization credential test failed"
            echo "Possible issues:"
            echo "1. Apple ID password might have expired"
            echo "2. Team ID might be incorrect"
            echo "3. Two-factor authentication might be required"
            exit 1
          }
        
        echo "✅ Notarization credentials verified successfully"
        
    - name: Create Notarization Profile
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        # Store notarization credentials
        xcrun notarytool store-credentials "DEV_CERT_PW" \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_ID_PASSWORD" \
          --team-id "$APPLE_TEAM_ID"

    # *** NEW DEBUG STEP: Backup original app and examine Qt plugins ***
    - name: Debug Qt Plugins Before Signing
      run: |
        echo "🔍 DEBUG: Examining Qt plugins BEFORE signing..."
        
        # Create backup for comparison
        echo "Creating backup of original app..."
        cp -R "dist/AV-Spex.app" "dist/AV-Spex-original.app"
        
        # Check Qt plugin structure
        QT_PLUGINS_DIR="dist/AV-Spex.app/Contents/Frameworks/PyQt6/Qt6/plugins"
        if [ -d "$QT_PLUGINS_DIR" ]; then
          echo "✅ Qt plugins directory found: $QT_PLUGINS_DIR"
          
          echo "=== Platform plugins (critical for theme detection) ==="
          if [ -d "$QT_PLUGINS_DIR/platforms" ]; then
            for plugin in "$QT_PLUGINS_DIR/platforms"/*.dylib; do
              if [ -f "$plugin" ]; then
                plugin_name=$(basename "$plugin")
                echo "  $plugin_name:"
                echo "    Size: $(stat -f%z "$plugin") bytes"
                echo "    Architecture: $(file "$plugin" | grep -o 'Mach-O.*')"
                echo "    Signature: $(codesign --display --verbose=1 "$plugin" 2>&1 | grep "Authority" || echo "unsigned")"
              fi
            done
          else
            echo "❌ No platforms directory found!"
          fi
          
          echo "=== Style plugins (for theme styling) ==="
          if [ -d "$QT_PLUGINS_DIR/styles" ]; then
            find "$QT_PLUGINS_DIR/styles" -name "*.dylib" | while read plugin; do
              echo "  $(basename "$plugin"): $(stat -f%z "$plugin") bytes"
            done
          else
            echo "ℹ️  No styles directory found (not critical)"
          fi
          
          echo "=== All Qt plugins summary ==="
          find "$QT_PLUGINS_DIR" -name "*.dylib" | wc -l | xargs echo "Total Qt plugins:"
          find "$QT_PLUGINS_DIR" -name "*.dylib" | head -10
          
        else
          echo "❌ Qt plugins directory not found!"
          echo "PyQt6 structure:"
          find "dist/AV-Spex.app/Contents/Frameworks/PyQt6" -type d | head -10
        fi
          
    - name: Sign App Bundle (Enhanced Debug)
      run: |
        # Create entitlements file
        cat > entitlements.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.cs.allow-jit</key>
            <true/>
            <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
            <true/>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
            <key>com.apple.security.cs.allow-dyld-environment-variables</key>
            <true/>
            <key>com.apple.security.automation.apple-events</key>
            <true/>
        </dict>
        </plist>
        EOF

        # Create minimal entitlements for Qt plugins
        cat > qt_entitlements.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
        </dict>
        </plist>
        EOF

        # Make sure permissions are correct
        chmod -R 755 dist/AV-Spex.app

        # TEST: Try signing ONE Qt plugin with maximum debug output
        echo "🔍 DEBUGGING: Testing signing on a single Qt plugin with full verbose output..."
        TEST_PLUGIN="dist/AV-Spex.app/Contents/Frameworks/PyQt6/Qt6/plugins/platforms/libqcocoa.dylib"
        
        echo "Before signing - plugin status:"
        ls -la "$TEST_PLUGIN"
        file "$TEST_PLUGIN"
        codesign --display --verbose=4 "$TEST_PLUGIN" 2>&1 || echo "No existing signature"
        
        echo "Certificate available for signing:"
        echo "CERT_NAME: $CERT_NAME"
        
        echo "Attempting to sign with full debug output..."
        codesign --force --timestamp --options runtime \
                 --entitlements qt_entitlements.plist \
                 --sign "$CERT_NAME" \
                 --verbose=4 \
                 "$TEST_PLUGIN" || {
          echo "❌ SIGNING FAILED! Error details:"
          codesign --force --timestamp --options runtime \
                   --entitlements qt_entitlements.plist \
                   --sign "$CERT_NAME" \
                   --verbose=4 \
                   "$TEST_PLUGIN" 2>&1 | head -20
          echo "Trying without entitlements..."
          codesign --force --timestamp --options runtime \
                   --sign "$CERT_NAME" \
                   --verbose=4 \
                   "$TEST_PLUGIN" || echo "Still failed without entitlements"
        }
        
        echo "After signing attempt - plugin status:"
        ls -la "$TEST_PLUGIN"
        echo "Detailed signature info:"
        codesign --display --verbose=4 "$TEST_PLUGIN" 2>&1 || echo "Still no signature detected"
        
        echo "Verification attempt:"
        codesign --verify --verbose=4 "$TEST_PLUGIN" 2>&1 || echo "Verification failed"
        
        # Now continue with the rest of the Qt plugins (only if the test worked)
        echo "🎨 Signing remaining Qt plugins..."
        if [ -d "dist/AV-Spex.app/Contents/Frameworks/PyQt6/Qt6/plugins" ]; then
          find "dist/AV-Spex.app/Contents/Frameworks/PyQt6/Qt6/plugins" -name "*.dylib" | while read plugin; do
            # Skip the test plugin since we already signed it
            if [ "$plugin" = "$TEST_PLUGIN" ]; then
              continue
            fi
            
            echo "Signing Qt plugin: $plugin"
            codesign --force --timestamp --options runtime \
                     --entitlements qt_entitlements.plist \
                     --sign "$CERT_NAME" "$plugin" || echo "Failed to sign $plugin"
          done
        fi

        # Sign other frameworks and libraries (simplified for debugging)
        echo "Signing other frameworks and libraries..."
        find dist/AV-Spex.app/Contents/Frameworks -type f \( -name "*.so" -o -name "*.dylib" \) 2>/dev/null | while read file; do
          # Skip Qt plugins as we already signed them
          if [[ "$file" == *"PyQt6/Qt6/plugins"* ]]; then
            continue
          fi
          
          if [ -f "$file" ]; then
            codesign --force --timestamp --options runtime \
                     --sign "$CERT_NAME" "$file" || echo "Warning: Failed to sign $file"
          fi
        done

        # Sign nested frameworks
        echo "Signing nested frameworks..."
        find dist/AV-Spex.app/Contents/Frameworks -name "*.framework" -type d 2>/dev/null | while read framework; do
          if [[ "$framework" == *"PyQt6/Qt6/plugins"* ]]; then
            continue
          fi
          
          if [ -d "$framework" ]; then
            codesign --force --timestamp --options runtime \
                     --sign "$CERT_NAME" "$framework" || echo "Warning: Failed to sign $framework"
          fi
        done

        # Sign the main executable
        echo "Signing main executable..."
        codesign --force --timestamp --options runtime \
                 --entitlements entitlements.plist \
                 --sign "$CERT_NAME" "dist/AV-Spex.app/Contents/MacOS/AV-Spex"

        # Sign the main app bundle
        echo "Signing main application bundle..."
        codesign --force --timestamp --options runtime \
                 --entitlements entitlements.plist \
                 --sign "$CERT_NAME" dist/AV-Spex.app

        echo "✅ Signing completed"

    # *** NEW DEBUG STEP: Compare before and after signing ***
    - name: Debug Qt Plugins After Signing
      run: |
        echo "🔍 DEBUG: Comparing Qt plugins BEFORE vs AFTER signing..."
        
        QT_PLUGINS_DIR="dist/AV-Spex.app/Contents/Frameworks/PyQt6/Qt6/plugins"
        ORIG_QT_PLUGINS_DIR="dist/AV-Spex-original.app/Contents/Frameworks/PyQt6/Qt6/plugins"
        
        echo "=== Platform plugins comparison ==="
        if [ -d "$QT_PLUGINS_DIR/platforms" ] && [ -d "$ORIG_QT_PLUGINS_DIR/platforms" ]; then
          for plugin in "$ORIG_QT_PLUGINS_DIR/platforms"/*.dylib; do
            if [ -f "$plugin" ]; then
              plugin_name=$(basename "$plugin")
              signed_plugin="$QT_PLUGINS_DIR/platforms/$plugin_name"
              
              echo "Plugin: $plugin_name"
              if [ -f "$signed_plugin" ]; then
                orig_size=$(stat -f%z "$plugin")
                signed_size=$(stat -f%z "$signed_plugin")
                
                echo "  Original: $orig_size bytes, $(codesign --display --verbose=1 "$plugin" 2>&1 | grep "Authority" || echo "unsigned")"
                echo "  Signed:   $signed_size bytes, $(codesign --display --verbose=1 "$signed_plugin" 2>&1 | grep "Authority" || echo "unsigned")"
                
                if [ "$orig_size" -eq "$signed_size" ]; then
                  echo "  ✅ Size unchanged"
                else
                  echo "  ⚠️  Size changed by $((signed_size - orig_size)) bytes"
                fi
                
                # Check if it's still a valid Mach-O file
                if file "$signed_plugin" | grep -q "Mach-O"; then
                  echo "  ✅ Still valid Mach-O binary"
                else
                  echo "  ❌ Binary appears corrupted!"
                fi
              else
                echo "  ❌ Plugin missing after signing!"
              fi
              echo ""
            fi
          done
        else
          echo "❌ Platform plugins directory missing!"
        fi
        
        echo "=== Signing summary ==="
        echo "Original app signature: $(codesign --display --verbose=1 "dist/AV-Spex-original.app" 2>&1 | grep "Authority" || echo "unsigned")"
        echo "Signed app signature: $(codesign --display --verbose=1 "dist/AV-Spex.app" 2>&1 | grep "Authority" || echo "signed")"
        
    - name: Create DMG
      run: |
        # Verify version is set
        if [ -z "$VERSION" ]; then
          echo "❌ VERSION environment variable is not set!"
          exit 1
        fi
        echo "📦 Creating DMG for version: $VERSION"
        
        # Create a folder (named dmg) to prepare our DMG in
        mkdir -p dist/dmg
        # Copy the signed app bundle to the dmg folder
        cp -R "dist/AV-Spex.app" dist/dmg/

        # Create the DMG with version number
        create-dmg \
          --volname "AV-Spex $VERSION" \
          --volicon "av_spex_the_logo.icns" \
          --window-pos 200 120 \
          --window-size 600 300 \
          --icon-size 100 \
          --icon "AV-Spex.app" 175 120 \
          --hide-extension "AV-Spex.app" \
          --app-drop-link 425 120 \
          --no-internet-enable \
          "dist/AV-Spex-$VERSION.dmg" \
          "dist/dmg"

        # Verify DMG was created
        if [ -f "dist/AV-Spex-$VERSION.dmg" ]; then
          echo "✅ DMG created successfully: AV-Spex-$VERSION.dmg"
          ls -la "dist/AV-Spex-$VERSION.dmg"
        else
          echo "❌ DMG creation failed!"
          exit 1
        fi

        # Sign the DMG itself
        echo "Signing DMG..."
        codesign --force --timestamp --sign "$CERT_NAME" "dist/AV-Spex-$VERSION.dmg"
        
    - name: Notarize DMG
      run: |
        # Submit for notarization
        echo "Submitting DMG for notarization..."
        xcrun notarytool submit "dist/AV-Spex-$VERSION.dmg" --keychain-profile "DEV_CERT_PW" --wait --timeout 1800

        # Staple the ticket to the DMG
        echo "Stapling ticket to DMG..."
        xcrun stapler staple "dist/AV-Spex-$VERSION.dmg"

        # Final verification after notarization
        echo "Final verification after notarization..."
        spctl --assess --type execute --verbose dist/AV-Spex.app
        spctl --assess --type install --verbose "dist/AV-Spex-$VERSION.dmg"

        echo "✅ Build and notarization process complete for AV-Spex version $VERSION!"
        
    - name: Upload signed DMG
      uses: actions/upload-artifact@v4
      with:
        name: AV-Spex-${{ env.VERSION }}-signed-dmg
        path: dist/AV-Spex-${{ env.VERSION }}.dmg
        retention-days: 90

    - name: Debug workflow_run context
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Workflow run event: ${{ github.event.workflow_run.event }}"
        echo "Head branch: ${{ github.event.workflow_run.head_branch }}"
        echo "Head SHA: ${{ github.event.workflow_run.head_sha }}"
        echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
        echo "All workflow_run context:"
        echo '${{ toJson(github.event.workflow_run) }}'
        
    - name: Create Release (for tags)
      if: startsWith(github.event.workflow_run.head_branch, 'v')
      uses: softprops/action-gh-release@v1
      with:
        files: dist/AV-Spex-${{ env.VERSION }}.dmg
        tag_name: ${{ github.event.workflow_run.head_branch }}  # <-- Use this instead of github.ref_name
        name: AV-Spex ${{ github.event.workflow_run.head_branch }}  # <-- And this
        draft: false
        prerelease: false
        body: |
          ## AV-Spex v${{ env.VERSION }}
          
          **Build Information:**
          - Built from commit: ${{ github.event.workflow_run.head_sha }}
          - Build workflow: ${{ github.event.workflow_run.id }}
          - Signed and notarized: ✅
          
          ### Installation
          1. Download the DMG file below
          2. Open the DMG and drag AV-Spex.app to your Applications folder
          3. The app is signed and notarized for macOS security
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Debug Release Status
      if: startsWith(github.event.workflow_run.head_branch, 'v')
      run: |
        echo "Checking release status for tag: ${{ github.event.workflow_run.head_branch }}"
        curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ github.event.workflow_run.head_branch }}" \
          | jq '.draft, .prerelease, .published_at, .html_url'
        
    - name: Cleanup Keychain
      if: always()
      run: |
        security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
