import os
import sys
import shutil
import re
from dataclasses import asdict
import time

from AV_Spex.utils.filename_validate import is_valid_filename

from AV_Spex.utils.log_setup import logger
from AV_Spex.utils.config_setup import ChecksConfig, SpexConfig
from AV_Spex.utils.config_manager import ConfigManager

config_mgr = ConfigManager()
checks_config = config_mgr.get_config('checks', ChecksConfig)
spex_config = config_mgr.get_config('spex', SpexConfig)

def validate_input_paths(input_paths, is_file_mode):
    source_directories = []
    for input_path in input_paths:
        try:
            if is_file_mode and not os.path.isfile(input_path):
                raise ValueError(f"Error: {input_path} is not a valid file.")
            elif not is_file_mode and not os.path.isdir(input_path):
                raise ValueError(f"Error: {input_path} is not a valid directory.")
            
            directory = os.path.dirname(input_path) if is_file_mode else input_path
            source_directories.append(directory)
            logger.info(f'Input directory found: {directory}\n')
        except ValueError as e:
            logger.critical(str(e))
            sys.exit(1)
    return source_directories


def move_vrec_files(directory, video_id):
    # Define expected file extensions once
    vrecord_extensions = (
        '_QC_output_graphs.jpeg',
        '_vrecord_input.log',
        '_capture_options.log',
        '.mkv.qctools.mkv',
        '.framemd5',
        '_frame_eia608data.txt',  
        '_VideoTransfer_Notes.txt',
        '.scc'
    )

    vrecord_directory = os.path.join(directory, f'{video_id}_vrecord_metadata')

    # Collect matching files from the main directory
    files_to_move = []
    for filename in os.listdir(directory):
        file_path = os.path.join(directory, filename)
        if os.path.isfile(file_path) and filename.endswith(vrecord_extensions):
            files_to_move.append((file_path, filename))

    # If no files to move, check if they're already in the vrecord directory
    if not files_to_move:
        if os.path.exists(vrecord_directory):
            existing_files = os.listdir(vrecord_directory)
            if any(f.endswith(vrecord_extensions) for f in existing_files):
                logger.debug(f"Existing vrecord files found in {os.path.basename(directory)}/{os.path.basename(vrecord_directory)}\n")
                return
        logger.debug("No vrecord files found.\n")
        return

    # Move files
    os.makedirs(vrecord_directory, exist_ok=True)
    for file_path, filename in files_to_move:
        shutil.move(file_path, os.path.join(vrecord_directory, filename))
    
    logger.debug(f"Files generated by vrecord found. '{video_id}_vrecord_metadata' directory created and files moved.\n")


def find_mkv(source_directory):
    # Create empty list to store any found mkv files
    found_mkvs = []
    for filename in os.listdir(source_directory):
        if filename.lower().endswith('.mkv'):
            if 'qctools' not in filename.lower():
                found_mkvs.append(filename)
    # check if found_mkvs is more than one
    if found_mkvs:
        if len(found_mkvs) == 1:
            video_path = os.path.join(source_directory, found_mkvs[0])
            logger.info(f'Input video file found in {source_directory}: {video_path}\n')
        else:
            logger.critical(f'More than 1 mkv found in {source_directory}: {found_mkvs}\n')
            return None
    else:
        logger.critical(f"Error: No mkv video file found in the directory: {source_directory}\n")
        return None

    return video_path


def check_directory(source_directory, video_id):
    """
    Checks whether the base name of a directory matches the given video_id.
    
    Args:
        source_directory (str): The path to the directory.
        video_id (str): The expected video ID to match.

    Returns:
        bool: True if the directory name matches the video_id, otherwise False.
    """
    directory_name = os.path.basename(source_directory)
    if directory_name.startswith(video_id):
        logger.info(f'Directory name "{directory_name}" correctly matches video file name "{video_id}".\n')
        return True
    else:
        logger.critical(f'Directory name "{directory_name}" does not correctly match the expected "{video_id}".\n')
        return False


def make_qc_output_dir(source_directory, video_id):
    '''
    Creates output directory for metadata files
    '''
    config_mgr = ConfigManager()
    checks_config = config_mgr.get_config('checks', ChecksConfig)
    tools_config = checks_config.tools
    
    # Helper to check if a tool is enabled
    def is_tool_enabled(tool_name):
        tool = getattr(tools_config, tool_name, None)
        if tool is None:
            return False
        return getattr(tool, 'check_tool', False) or getattr(tool, 'run_tool', False)
    
    # Check if any metadata tools are enabled
    metadata_tools_enabled = (
        any(is_tool_enabled(tool) for tool in ['mediainfo', 'mediatrace', 'exiftool', 'ffprobe'])
        or tools_config.qctools.run_tool
        or tools_config.qct_parse.run_tool
        or checks_config.fixity.check_fixity
    )
    
    destination_directory = os.path.join(source_directory, f'{video_id}_qc_metadata')
    
    if metadata_tools_enabled and not os.path.exists(destination_directory):
        os.makedirs(destination_directory)
        logger.debug(f'Metadata files will be written to {destination_directory}\n')
    
    return destination_directory


def make_report_dir(source_directory, video_id):
    '''
    Creates output directory for metadata files
    '''

    report_directory = os.path.join(source_directory, f'{video_id}_report_csvs')

    if os.path.exists(report_directory):
        shutil.rmtree(report_directory)
    os.makedirs(report_directory)

    logger.debug(f'Report files will be written to {report_directory}\n')

    return report_directory


def initialize_directory(source_directory):
    """
    Prepare the directory for processing by finding the video file 
    and optionally validating the filename based on config settings.

    Args:
        source_directory (str): Path to the source directory

    Returns:
        tuple: (video_path, video_id, destination_directory, access_file_found) if successful
        None if preparation fails
    """
    # Get current time as a time structure
    local_time = time.localtime()
    # Format the time into a custom string (Year-Month-Day Hour:Minute:Second)
    formatted_time = time.strftime("%Y-%m-%d %H:%M:%S", local_time)
    logger.warning(f'Current local time: {formatted_time}\n')
    
    video_path = find_mkv(source_directory)

    if video_path is None:
        logger.warning(f"Skipping {source_directory} due to error.\n")
        return None  # Indicates preparation failed

    # Get the latest checks config to see if filename validation is enabled
    config_mgr.refresh_configs()  # Ensure we have the latest config
    current_checks = config_mgr.get_config('checks', ChecksConfig, use_last_used=True)
    
    # Only validate filename if the toggle is enabled
    if current_checks.validate_filename:
        valid_filename = is_valid_filename(video_path)
        
        if valid_filename is False:
            logger.warning(f"Skipping {source_directory} due to filename validation error.\n")
            logger.info("To bypass filename validation, set 'validate_filename' to false in your Checks configuration.\n")
            return None  # Indicates preparation failed
        
        logger.info("Filename validation passed.\n")
    else:
        logger.info("Filename validation is disabled in configuration, proceeding without validation.\n")

    logger.warning(f'Now processing {video_path}\n')

    # outputs video_id (i.e. 'JPC_AV_05000')
    video_id = os.path.splitext(os.path.basename(video_path))[0]

    # Check to confirm directory is the same name as the video file name
    # This check is also bypassed when filename validation is disabled
    if current_checks.validate_filename:
        if not check_directory(source_directory, video_id):
            # Directory name doesn't match, but we only warn, not fail
            logger.warning("Directory name mismatch detected but continuing...\n")
    else:
        logger.debug(f"Directory name check skipped (filename validation disabled).\n")

    # Create 'destination directory' for qc outputs
    destination_directory = make_qc_output_dir(source_directory, video_id)

    # Moves vrecord files to subdirectory  
    move_vrec_files(source_directory, video_id)

    # Iterate through files in the directory to identify access file
    access_file_found = None
    for filename in os.listdir(source_directory):
        if filename.lower().endswith('mp4'):
            access_file_found = filename
            logger.info("Existing access file found!\n")
            break

    return video_path, video_id, destination_directory, access_file_found